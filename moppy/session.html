<!DOCTYPE html>
<html lang="en" class="dark bg-terminal-bg">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Session - MOP</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            'terminal-bg': '#0c0c0c',
            'terminal-text': '#f0f0f0',
            'terminal-green': '#4ade80',
            'terminal-red': '#f87171',
            'terminal-blue': '#60a5fa',
            'terminal-gray': '#555555'
          }
        }
      }
    }
  </script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap');
    body {
      font-family: 'Fira Code', monospace;
      background-color: #0c0c0c;
      color: #f0f0f0;
    }
    #terminal-output {
      height: 60vh;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
      padding: 1rem;
      background: #000;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
    }
    .blink {
      animation: blink 1s step-end infinite;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
    .status-badge {
      font-size: 0.8rem;
      padding: 0.25rem 0.5rem;
      border-radius: 999px;
    }
  </style>
</head>
<body class="min-h-screen p-4 sm:p-6">
  <div class="max-w-4xl mx-auto">
    <!-- Header -->
    <div class="flex flex-wrap justify-between items-center mb-4 gap-2">
      <h1 class="text-xl font-bold text-terminal-green">MOP Session</h1>
      <div class="flex items-center gap-3">
        <span id="status-badge" class="status-badge bg-terminal-red text-black blink">Offline</span>
        <button id="end-session" class="text-sm bg-terminal-red hover:bg-red-700 text-white px-3 py-1 rounded">
          End Session
        </button>
        <button id="back-home" class="text-sm bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded">
          ← Home
        </button>
        <button id="copy-key" class="text-sm bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded">
          Copy Key
        </button>
      </div>
    </div>

    <!-- Terminal Output -->
    <div id="terminal-output" class="font-mono text-sm"></div>

    <!-- Input -->
    <div class="flex">
      <span class="text-terminal-gray mr-2">❯</span>
      <input
        type="text"
        id="stdin-input"
        placeholder="Type command..."
        class="flex-grow bg-transparent border-b border-terminal-gray focus:outline-none focus:border-terminal-green pb-1"
        autocomplete="off"
        spellcheck="false"
      />
    </div>

    <!-- Footer -->
    <div class="mt-4 text-xs text-terminal-gray">
      Session key: <code id="session-key-display" class="ml-1">...</code>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/ansi_up@5.0.0/ansi_up.min.js"></script>
  <script>
    const API_BASE = '';
    const urlParams = new URLSearchParams(window.location.search);
    let sessionKey = urlParams.get('key');
    let isNewSession = urlParams.get('new') === '1';
    let old_data_length = 0
    let ctrlCPressed = false;
    let hasNotCtrlCBeenPressed = true;
    let stdout_offset = 0;
    const ansi_up = new AnsiUp();
    const outputEl = document.getElementById('terminal-output');
    const inputEl = document.getElementById('stdin-input');
    const statusBadge = document.getElementById('status-badge');
    const endSessionBtn = document.getElementById('end-session');
    const backHomeBtn = document.getElementById('back-home');
    const keyDisplay = document.getElementById('session-key-display');
    const copyKeyBtn = document.getElementById('copy-key');
    

    // Recover key from localStorage if not in URL
    if (!sessionKey) {
      sessionKey = localStorage.getItem('mop_key');
    }

    if (!sessionKey) {
      alert('No session key provided. Returning to home.');
      window.location.href = '/';
    }

    keyDisplay.textContent = sessionKey.substring(0, 16) + '...';

    let isAlive = false;
    let reconnectTimeout = null;
    let shouldReconnect = true;
    
    window.addEventListener('keydown', (event) => {
      if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'c') {
        ctrlCPressed = true;
      }
    });

    // Ping session status
    async function pingSession() {
      try {
        const res = await fetch(`${API_BASE}/mop/ping`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key: sessionKey })
        });

        if (res.ok) {
          isAlive = true;
          updateStatus('Alive', 'bg-terminal-green', false);
        } else if (res.status === 410) {
          isAlive = false;
          updateStatus('Terminated', 'bg-terminal-red', false);
          shouldReconnect = false;
        } else {
          isAlive = false;
          updateStatus('Unknown', 'bg-yellow-500', true);
        }
      } catch (err) {
        isAlive = false;
        updateStatus('Offline', 'bg-terminal-red', true);
      }
    }

    function updateStatus(text, bgColor, blinking = false) {
      statusBadge.textContent = text;
      statusBadge.className = `status-badge text-black ${bgColor}`;
      if (blinking) {
        statusBadge.classList.add('blink');
      } else {
        statusBadge.classList.remove('blink');
      }
    }

    function base64UrlDecode(input) {
      // If input is an array, process each part and join them
      if (Array.isArray(input)) {
        return input.map(part => base64UrlDecode(part)).join('');
      }

      // Fallback: if input is null or not a string, return empty
      if (typeof input !== 'string') return '';

      // 1. Normalize URL-safe characters
      let base64 = input.replace(/-/g, '+').replace(/_/g, '/');

      // 2. Fix padding
      while (base64.length % 4) {
        base64 += '=';
      }

      try {
        // 3. Decode binary string
        const binaryString = atob(base64);

        // 4. Convert to bytes for UTF-8 support
        const bytes = Uint8Array.from(binaryString, c => c.charCodeAt(0));

        // 5. Return the decoded string
        return new TextDecoder('utf-8').decode(bytes);
      } catch (e) {
        console.error("Failed to decode chunk:", input, e);
        return '';
      }
    }
    

    // Fetch and render output
    async function fetchOutput() {
        if (!isAlive && !shouldReconnect) return;

        try {
            const res = await fetch(`${API_BASE}/mop/read`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ key: sessionKey })
            });

            if (res.ok) {
            const data = await res.json();
            if (Array.isArray(data.stdout)) {
                if (data.stdout.length > old_data_length) {
                    old_data_length = data.stdout.length;

                    // Decode the ENTIRE stdout array (all chunks)
                    const fullDecoded = base64UrlDecode(data.stdout); // ← your function handles list → str

                    // Find the LAST occurrence of \x1b[2J in the full decoded string
                    const lastClearIndex = fullDecoded.lastIndexOf('\x1b[2J');

                    let displayText;
                    if (lastClearIndex !== -1) {
                        // Show everything AFTER the last clear
                        displayText = fullDecoded.slice(lastClearIndex + 4); // 4 = length of '\x1b[2J'
                    } else {
                        // No clear: show everything
                        displayText = fullDecoded;
                    }

                    try {
                        outputEl.innerHTML = ansi_up.ansi_to_html(displayText);
                    } catch {
                        outputEl.innerHTML = displayText.replace(/(?:\x1B|\u001b)\[[0-?]*[ -/]*[@-~]/g, '');
                    }

                    scrollToBottom();
                } else {
                  console.log('No new data')
                }
            } 
            } else if (res.status === 404 || res.status === 400) {
            updateStatus('Invalid Session', 'bg-terminal-red', false);
            shouldReconnect = false;
            }
        } catch (err) {
            // Silent fail — ping will handle connectivity status
        }
    }

    function scrollToBottom() {
      outputEl.scrollTop = outputEl.scrollHeight;
    }

    // Send stdin
    async function sendInput() {
      const cmd = inputEl.value.trim();
      if (!isAlive) return;

      inputEl.value = '';
      inputEl.disabled = true;

      try {
        const res = await fetch(`${API_BASE}/mop/write`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key: sessionKey, stdin: cmd })
        });

        if (!res.ok) {
          outputEl.textContent += `\n[Write error: ${res.status}]`;
          scrollToBottom();
        }
        // Output will appear on next /read
      } catch (err) {
        outputEl.textContent += `\n[Write failed: ${err.message}]`;
        scrollToBottom();
      } finally {
        inputEl.disabled = false;
        inputEl.focus();
      }
    }

    // End session
    async function endSession() {
      if (!confirm('End this session permanently?')) return;

      try {
        await fetch(`${API_BASE}/mop/end`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key: sessionKey })
        });
      } catch (err) {
        console.warn('End session failed:', err);
      } finally {
        localStorage.removeItem('mop_key');
        window.location.href = '/';
      }
    }

    async function sendSignal(signal) {
      try {
        await fetch(`${API_BASE}/mop/signal`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key: sessionKey, signal })
        });
      } catch (err) {
        console.warn('Send signal failed:', err);
      }
    }

    // Auto-refresh loop
    async function startSession() {
      if (ctrlCPressed) return;
      await pingSession();
      if (isAlive) {
        await fetchOutput();
      }
  
      // Schedule next update
      const interval = isAlive ? 500 : 2000; // Faster when alive
      if (shouldReconnect) {
        reconnectTimeout = setTimeout(startSession, interval);
      }
    }

    async function sessionLoop() {
      while (shouldReconnect && !ctrlCPressed) {
        await pingSession();
        if (isAlive) {
          await fetchOutput();
        }
        await new Promise(r => setTimeout(r, isAlive ? 500 : 2000));
      }
    }

    // Event Listeners
    inputEl.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendInput();
    });

    endSessionBtn.addEventListener('click', endSession);
    backHomeBtn.addEventListener('click', () => {
      window.location.href = '/';
    });

    copyKeyBtn.addEventListener('click', () => {
      navigator.clipboard.writeText(sessionKey);
    });

    setInterval(async () => {
        if (ctrlCPressed && hasNotCtrlCBeenPressed) {
            await sendSignal('INTERRUPT');
            alert('Program terminated.');
            localStorage.removeItem('mop_key');
            isAlive = false;
            hasNotCtrlCBeenPressed = false;
            updateStatus('Terminated', 'bg-terminal-red', false);
            shouldReconnect = false;
        }
      }, 100);

    // Initial load

    // startSession();
    sessionLoop();
    inputEl.focus();

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      clearTimeout(reconnectTimeout);
    });
  </script>
</body>
</html>